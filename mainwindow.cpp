#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "testsresults.h"
#include "windows.h"
#include <QDebug>
#include <QtSerialPort/QSerialPortInfo>
#include <QPushButton>
#include <QMessageBox>
#include <QTextEdit>
#include <QTextCodec>
#include <QApplication>
#include <QFile>
#include <QFileInfo>

// Исполнено
#define UVK20_RES_OK            0x80000000
// Исполнено: СПО записано
#define UVK20_RES_OK_SPOLOAD    0x80000001
// Исполнено: СПО стерто
#define UVK20_RES_OK_SPOERASE   0x80000002
// Исполнено: СИ записано
#define UVK20_RES_OK_SILOAD     0x80000003
// Исполнено: СИ стерто
#define UVK20_RES_OK_SIERASE    0x80000004
// Ошибка: контрольной суммы
#define UVK20_RES_FAIL_CS       0x00010000
// Ошибка: неверная команда
#define UVK20_RES_FAIL_CMND     0x00020000
// Ошибка: неверно заполненное поле
#define UVK20_RES_FAIL_POLE     0x00040000
// Ошибка: чтение ГСЧ
#define UVK20_RES_FAIL_GS4      0x00080000
// Ошибка: переполнение
#define UVK20_RES_FAIL_OVERF    0x00100000
// Ошибка: загрузки СПО
#define UVK20_RES_FAIL_SPOLOAD  0x00200000
// Ошибка: стирание СИ
#define UVK20_RES_FAIL_SIERASE  0x00400000
// Ошибка: стирание СПО
#define UVK20_RES_FAIL_SPOERASE 0x00800000
// Ошибка: отсутствует СИ
#define UVK20_RES_FAIL_SINO     0x01000000
// Ошибка: СИ существует
#define UVK20_RES_FAIL_SIYES    0x02000000
// Ошибка: неверная конфигурация
#define UVK20_RES_FAIL_GCONFNO  0x04000000
// Ошибка: запись конфигурации
#define UVK20_RES_FAIL_GCONF    0x08000000

// Неизвестная ошибка
#define UVK20_RES_FAIL_UNNOWN   0xFFFFFFFF

#define SIZE_FOR_CONTROSUM_TS1  4

#define SIZE_FOR_SUB_FORCHECKTS2  8
//отдельно класс для сериал порт
//отдельно класс для кольцевого буфера
//пофиксить ошибки
//Запись в файл и выгрузка
typedef struct {
    uint8_t*buffer;
    size_t buffer_size;
    size_t head;
    size_t tail;
    size_t bytes_avail;
    
} queue_t;


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
    , serial(new QSerialPort(this))
{
    ui->setupUi(this);
    try {
        connect(serial,&QSerialPort::readyRead,this,&MainWindow::serialRecieve);
        connect(ui->pushButton,SIGNAL(clicked()),this,SLOT(on_pushButtonWritetootherCOMport()));
        connect(serial,&QSerialPort::errorOccurred, this, &MainWindow::handleError);
        connect(ui->pushButton_2,SIGNAL(clicked()),this,SLOT(on_pushButtonExit()));
        connect(ui->pushButton_3,SIGNAL(clicked()),this,SLOT(connecttoSerialPort()));
        connect(ui->clsbut,SIGNAL(clicked()),this,SLOT(clsfun()));
        connect(ui->checktests_btn,SIGNAL(clicked()),this,SLOT(nextpageforresult()));
        const auto infos = QSerialPortInfo::availablePorts();
        for (const QSerialPortInfo &info : infos) {
            ui->PortComboBox->addItem(info.portName());
        }
        MainWindow::initiat();
    }
    catch (const std::bad_alloc &) {
        qDebug()<<"Exeception";
    }
}
MainWindow::~MainWindow()
{
    delete ui;
    serial->close();
}
unsigned char SPOmassive[] = {0x33,0x28,0x07};
QByteArray TOWRITE_FOR_SPO{};
uint8_t shufflearr[80] = {};
uint8_t GSCarray[160] = {};
uint8_t seria2[1280] = {
    0xff, 0x44,/*(начало заголовка)*/ 0x01, 0x00,/*(номер ключа)*/ 0x01, 0x00,/*(версия)*/ 0x00, 0x02,/*(номер серии)*/ 0x09, 0x5d, 0xc3, 0x6e, 0x67, 0xab, 0x8d, 0x69, 0x5e, // 17
    0x47, 0xe4, 0x97, 0x67, 0x7d, 0xcf, 0x03, 0xf7, 0xe3, 0xa9, 0x06, 0xe4, 0x45, 0x1a, 0x9e, 0x34,
    0x0c, 0xd3, 0xae, 0x49, 0xfe, 0xa9, 0x2b, 0x73, 0x98, 0x30, 0xc0, 0xb3, 0x5f, 0x02, 0x0b, 0xe2,
    0x28, 0x70, 0xac, 0xd5, 0xa0, 0xe9, 0x70, 0xf0, 0xaf, 0x09, 0x9c, 0x88, 0x09, 0xa8, 0x6f, 0x44,
    0xe5, 0xdb, 0x9b, 0x4f, 0x5e, 0x74, 0x2d, 0x6a, 0xbd, 0x1c, 0x16, 0xa3, 0xe5, 0xb9, 0xc1,/*(остальное ключ)*/ 0xff,
    0x44, 0x02, 0x00, 0x01, 0x00, 0x00, 0x02, 0xa7, 0x2f, 0x57, 0xe8, 0x88, 0xab, 0x51, 0x03, 0x07,
    0x5d, 0xad, 0xbd, 0xd7, 0xc6, 0xdc, 0x3b, 0x04, 0x7b, 0xa4, 0xea, 0xb3, 0xb5, 0x00, 0xf1, 0x6f,
    0x1b, 0x59, 0xd6, 0x36, 0x17, 0xad, 0x5d, 0x03, 0x06, 0x83, 0x32, 0xf3, 0x1e, 0x9b, 0xb5, 0x37,
    0x4c, 0xa4, 0xba, 0x62, 0xb1, 0x81, 0x26, 0x61, 0xb0, 0xc8, 0xd2, 0x41, 0x60, 0x1a, 0xd1, 0xac,
    0xe2, 0x45, 0x6e, 0x41, 0x13, 0xb5, 0x86, 0x4e, 0x04, 0x46, 0x73, 0xc3, 0x36, 0x46, 0x8e, 0xff,
    0x44, 0x03, 0x00, 0x01, 0x00, 0x00, 0x02, 0x02, 0xfc, 0x0b, 0x23, 0xd5, 0xce, 0xc7, 0x28, 0x77,
    0x69, 0x87, 0x1e, 0x0c, 0xad, 0x84, 0xb9, 0x8f, 0x52, 0xa1, 0xd3, 0x35, 0xcb, 0xe6, 0x5b, 0x4f,
    0xd3, 0x36, 0x39, 0x24, 0xde, 0x1e, 0x95, 0x73, 0x10, 0x0f, 0x58, 0x4d, 0x32, 0x8a, 0x60, 0xdf,
    0x4a, 0xee, 0xbd, 0x74, 0xf0, 0x0a, 0xec, 0x48, 0xdf, 0xa3, 0x1b, 0x65, 0x72, 0x89, 0xe5, 0x87,
    0x70, 0x6c, 0x24, 0x05, 0xc0, 0x97, 0xa3, 0x4c, 0xcb, 0x99, 0x80, 0x8f, 0xa0, 0x95, 0x33, 0xff,
    0x44, 0x04, 0x00, 0x01, 0x00, 0x00, 0x02, 0xba, 0xcc, 0x0e, 0x3e, 0x71, 0x18, 0x19, 0x01, 0x4a,
    0x62, 0xec, 0x89, 0xe7, 0x8b, 0x6b, 0xfa, 0x6c, 0xcc, 0xb4, 0xc1, 0x3c, 0xdc, 0xf1, 0x80, 0xe4,
    0x08, 0x8e, 0x49, 0xea, 0x48, 0x7c, 0x94, 0xe0, 0x1e, 0xec, 0x85, 0xdb, 0xdc, 0x1b, 0x56, 0x78,
    0xce, 0xa1, 0xac, 0xf9, 0x9d, 0xf3, 0xba, 0x75, 0x36, 0x47, 0x9d, 0x1c, 0x33, 0x04, 0xd7, 0xbe,
    0xb9, 0x6f, 0x39, 0x59, 0x6f, 0x17, 0x1b, 0xfb, 0x82, 0xb8, 0xcd, 0x5c, 0xe4, 0x4f, 0xe5, 0xff,
    0x44, 0x05, 0x00, 0x01, 0x00, 0x00, 0x02, 0x1f, 0x1f, 0x52, 0xf5, 0xfd, 0x95, 0x4d, 0x89, 0xbe,
    0xf0, 0x17, 0x50, 0xf3, 0xde, 0xae, 0x72, 0x59, 0xc5, 0x80, 0x33, 0x65, 0x3c, 0xd5, 0x80, 0x88,
    0xd9, 0x2a, 0xdd, 0x75, 0xde, 0x55, 0xd6, 0xe9, 0xa3, 0xc0, 0x21, 0x7b, 0xa1, 0xf2, 0xe2, 0x3b,
    0xd1, 0x64, 0x73, 0xaf, 0x25, 0x7a, 0xf0, 0xf3, 0x1a, 0xba, 0x18, 0x1f, 0xea, 0x72, 0x05, 0x8c,
    0x85, 0xd4, 0x47, 0x5f, 0x7f, 0x2c, 0x4c, 0x1a, 0x63, 0xf1, 0x1b, 0x46, 0x33, 0x56, 0x48, 0xff,
    0x44, 0x06, 0x00, 0x01, 0x00, 0x00, 0x02, 0xb1, 0x6d, 0xc6, 0x73, 0xc2, 0x01, 0x06, 0x73, 0x1d,
    0x6f, 0x9a, 0x7b, 0x44, 0xa7, 0xc9, 0x7c, 0xb5, 0x41, 0x2a, 0xd5, 0x9b, 0x06, 0xd9, 0x11, 0x5e,
    0xb2, 0x43, 0xe8, 0x51, 0x9e, 0xb0, 0x0c, 0x3a, 0x0f, 0x82, 0xcf, 0x7c, 0xec, 0xea, 0x8a, 0xa5,
    0x69, 0x8e, 0x2a, 0x1b, 0xae, 0x8a, 0x1d, 0xe8, 0x76, 0x98, 0x37, 0xeb, 0x10, 0x23, 0x70, 0x87,
    0xa4, 0x59, 0x41, 0xd2, 0x8a, 0x54, 0x00, 0x51, 0x77, 0xcf, 0xee, 0x00, 0x9b, 0x1f, 0x20, 0xff,
    0x44, 0x07, 0x00, 0x01, 0x00, 0x00, 0x02, 0x14, 0xbe, 0x9a, 0xb8, 0xc0, 0x45, 0x52, 0xc7, 0x60,
    0xfd, 0xc3, 0x70, 0xf1, 0x85, 0x3c, 0xb7, 0xa6, 0xcf, 0xb2, 0x09, 0x62, 0xbd, 0x73, 0x1d, 0xa5,
    0x94, 0x0a, 0xff, 0xbb, 0xd3, 0x03, 0x30, 0x80, 0xb8, 0x60, 0xe0, 0x0c, 0x77, 0xea, 0x3a, 0xac,
    0xe5, 0xcd, 0xbb, 0x07, 0x44, 0x10, 0x6f, 0xa2, 0x11, 0x76, 0x29, 0x3b, 0xe0, 0xad, 0x58, 0x46,
    0x01, 0x8b, 0x8a, 0x87, 0x35, 0x48, 0xbb, 0x71, 0xde, 0xaf, 0x7a, 0xf3, 0xdc, 0x3a, 0xfc, 0xff,
    0x44, 0x08, 0x00, 0x01, 0x00, 0x00, 0x02, 0xc1, 0x0c, 0xcc, 0x49, 0x0e, 0xd6, 0xe4, 0x2f, 0xb9,
    0xa0, 0xac, 0x19, 0x25, 0xa4, 0xa2, 0xae, 0x99, 0xda, 0x9d, 0xd6, 0x14, 0x3a, 0x42, 0xb1, 0x8d,
    0x99, 0x52, 0x71, 0x5d, 0x4a, 0xcc, 0xf6, 0xb6, 0xce, 0xdf, 0xc6, 0xff, 0x9c, 0x8d, 0x40, 0x9b,
    0xd5, 0xee, 0x23, 0xe7, 0xf0, 0x01, 0x38, 0xd5, 0xf1, 0xb7, 0x33, 0xf1, 0xf7, 0x9d, 0x09, 0xdc,
    0xd7, 0xa5, 0x1f, 0x66, 0x72, 0x1a, 0x1e, 0x31, 0xe5, 0x0e, 0x8d, 0xf0, 0x2b, 0x0d, 0x1a, 0xff,
    0x44, 0x09, 0x00, 0x01, 0x00, 0x00, 0x02, 0x64, 0xdf, 0x90, 0x82, 0xec, 0x18, 0x81, 0xca, 0x61,
    0xe1, 0x62, 0xe0, 0xc3, 0xd2, 0xe1, 0x40, 0xfa, 0xa2, 0xe5, 0x99, 0xb1, 0x2d, 0x5c, 0xad, 0x29,
    0x00, 0xea, 0x27, 0xb3, 0xd5, 0xeb, 0xfe, 0x54, 0x3a, 0xa6, 0xb6, 0xea, 0xb7, 0x56, 0x13, 0x5c,
    0x6e, 0x74, 0x5a, 0x6a, 0x7d, 0x22, 0xe6, 0xc4, 0xaf, 0x61, 0x17, 0x0c, 0x09, 0x49, 0xf5, 0x9a,
    0xd8, 0xd6, 0xcb, 0xec, 0x70, 0xa3, 0x83, 0x29, 0x84, 0xd6, 0xc8, 0xfb, 0x1f, 0xea, 0x88, 0xff,
    0x44, 0x0a, 0x00, 0x01, 0x00, 0x00, 0x02, 0xca, 0xad, 0x04, 0x04, 0x4f, 0x04, 0x5a, 0x0f, 0x38,
    0x8d, 0xbb, 0x3f, 0xdb, 0x52, 0xe0, 0xbe, 0x9e, 0xff, 0x22, 0xf4, 0x7c, 0xd2, 0x2a, 0x2f, 0xff,
    0xf3, 0xb8, 0xd3, 0x58, 0x67, 0x80, 0xb8, 0x64, 0x09, 0x84, 0x8a, 0x3e, 0x06, 0x8a, 0xe5, 0x2a,
    0x5b, 0x30, 0x0a, 0xcf, 0x79, 0xe6, 0x13, 0xe6, 0x6c, 0x08, 0x39, 0x28, 0x5f, 0xa3, 0x32, 0x29,
    0x62, 0x88, 0x16, 0x95, 0xff, 0x58, 0x37, 0x71, 0x57, 0x65, 0x7e, 0xf2, 0xed, 0x12, 0x84, 0xff,
    0x44, 0x0b, 0x00, 0x01, 0x00, 0x00, 0x02, 0x6f, 0x7e, 0x58, 0xcf, 0x78, 0xe1, 0x3b, 0x73, 0x54,
    0xa5, 0x81, 0x27, 0x32, 0xfa, 0x77, 0x77, 0xa2, 0xb4, 0xcd, 0x40, 0xf8, 0xb6, 0x14, 0x6d, 0x98,
    0x6b, 0x47, 0x72, 0x09, 0x5d, 0xd2, 0x87, 0xc0, 0x5b, 0xbc, 0xf0, 0x43, 0x2c, 0x1e, 0xaa, 0x0f,
    0xa8, 0xf9, 0x7c, 0x5f, 0x69, 0x03, 0xb9, 0xe5, 0x1d, 0xc8, 0x3f, 0xbe, 0x35, 0x77, 0x25, 0xe8,
    0x7d, 0x39, 0xa1, 0xa1, 0xf5, 0x03, 0xe6, 0xdd, 0x0c, 0xc7, 0xa4, 0x46, 0x7d, 0xbb, 0x29, 0xff,
    0x44, 0x0c, 0x00, 0x01, 0x00, 0x00, 0x02, 0xd7, 0x4e, 0x5d, 0xd2, 0x60, 0x95, 0x67, 0xc6, 0x79,
    0x03, 0xd2, 0xc0, 0xaa, 0xcd, 0x7b, 0xf5, 0x02, 0x65, 0xaf, 0x67, 0xb9, 0xb9, 0x3e, 0xe3, 0x6b,
    0x2c, 0xd6, 0x77, 0x35, 0xbd, 0x0a, 0xa9, 0x71, 0x40, 0x7b, 0x6f, 0x05, 0x94, 0x78, 0x1a, 0x6d,
    0xd3, 0x93, 0x4d, 0x77, 0x33, 0x3c, 0xd0, 0xf8, 0x61, 0xbe, 0x83, 0x9e, 0xcd, 0xbc, 0x70, 0x00,
    0xb9, 0xcb, 0xa2, 0x3b, 0x6d, 0x95, 0x32, 0xda, 0x1c, 0x5e, 0xda, 0xd1, 0xab, 0xa3, 0x90, 0xff,
    0x44, 0x0d, 0x00, 0x01, 0x00, 0x00, 0x02, 0x72, 0x9d, 0x01, 0x19, 0xe3, 0x8e, 0x3c, 0x56, 0xc6,
    0x8e, 0x55, 0xae, 0xec, 0xac, 0x4a, 0xb0, 0x60, 0xfc, 0xd5, 0xc5, 0x82, 0xc2, 0x24, 0xa0, 0x66,
    0x6f, 0x00, 0xa3, 0x1f, 0xa6, 0x0f, 0x59, 0x33, 0xc2, 0x6c, 0xd0, 0xaf, 0xb0, 0x43, 0x20, 0x46,
    0x95, 0xce, 0x87, 0x9b, 0x36, 0x0d, 0xb8, 0x5a, 0xe3, 0xf9, 0x7e, 0x71, 0xc1, 0x5f, 0x72, 0xfa,
    0x0c, 0x1e, 0xc1, 0x09, 0xc3, 0xed, 0x62, 0xb6, 0x1c, 0x43, 0x3f, 0x8f, 0xf0, 0x73, 0x0d, 0xff,
    0x44, 0x0e, 0x00, 0x01, 0x00, 0x00, 0x02, 0xdc, 0xef, 0x95, 0x9f, 0xd0, 0xcc, 0x79, 0xc3, 0x0a,
    0x52, 0x1c, 0xfd, 0x1a, 0xd8, 0x1d, 0x7f, 0x10, 0x3a, 0x3b, 0xac, 0x4d, 0xe8, 0x41, 0xf0, 0x90,
    0xf4, 0x9b, 0x0f, 0x0a, 0x2a, 0xc4, 0xba, 0x30, 0xad, 0x43, 0x8d, 0xee, 0xaa, 0x26, 0xbd, 0x35,
    0xc8, 0x78, 0x0e, 0x24, 0x70, 0x16, 0x93, 0xf5, 0xad, 0x19, 0xd4, 0x91, 0xd9, 0xb4, 0xdd, 0x19,
    0x76, 0xcf, 0x70, 0xf5, 0xab, 0xca, 0x01, 0xff, 0x15, 0xd6, 0xb5, 0xbf, 0x89, 0xcc, 0xd2, 0xff,
    0x44, 0x0f, 0x00, 0x01, 0x00, 0x00, 0x02, 0x79, 0x3c, 0xc9, 0x54, 0x49, 0x0a, 0x00, 0x0a, 0x0e,
    0x23, 0x74, 0x53, 0x2b, 0xc9, 0xa5, 0xbb, 0x29, 0x4e, 0x08, 0xeb, 0x94, 0x4f, 0xab, 0x12, 0x3c,
    0x2c, 0xed, 0x6b, 0xef, 0x8f, 0x0f, 0x11, 0xc5, 0x16, 0xcb, 0xe5, 0xde, 0xfc, 0x78, 0x01, 0xb1,
    0xcb, 0x3d, 0xb9, 0xa2, 0x5b, 0x75, 0x6e, 0x32, 0x94, 0x1d, 0x0e, 0xfe, 0xd7, 0xfb, 0x42, 0xa9,
    0x64, 0x0c, 0xc4, 0x1f, 0xa4, 0x71, 0xa6, 0xd1, 0x93, 0xdf, 0x2a, 0xa6, 0xb4, 0x23, 0x89, 0xff,
    0x44, 0x10, 0x00, 0x01, 0x00, 0x00, 0x02, 0x37, 0x8c, 0x49, 0xa6, 0xba, 0xbf, 0x13, 0x94, 0x23,
    0x4e, 0xf6, 0x9c, 0x8b, 0xc0, 0x78, 0x72, 0x94, 0x38, 0xc7, 0x23, 0x1f, 0x54, 0xd6, 0x18, 0xe2,
    0xea, 0x59, 0x82, 0xee, 0x64, 0x98, 0xb4, 0x69, 0x00, 0x46, 0x57, 0x1f, 0xb6, 0x59, 0x1a, 0xc3,
    0xd0, 0x51, 0xbb, 0xd7, 0xa7, 0x6b, 0x8e, 0xda, 0x0f, 0xaf, 0x41, 0x7c, 0x72, 0x54, 0x14, 0x0b,
    0xa4, 0x32, 0xea, 0x00, 0x1f, 0x43, 0xdd, 0x34, 0x98, 0xac, 0x7c, 0x8a, 0xb1, 0x75, 0x84};

unsigned short CRC16TAB[256];
struct HEADing {
    uint8_t Separatorattribute = 0;
    uint8_t Namecomand;
    uint16_t LengthMessage;
    uint8_t Indifier;
    uint8_t ControSum ;
};
struct BODYmsg {
    uint32_t TS1;
    QList<uint8_t> TS2;
    uint32_t TS3; 
};
void MainWindow::clsfun() {
    ui->textEdit->setText("");
}
void MainWindow::connecttoSerialPort() {
    if (ui->PortComboBox->currentText()!="") {
        serial->setPortName(ui->PortComboBox->currentText());
        serial->setBaudRate(QSerialPort::Baud9600);
        serial->setDataBits(QSerialPort::Data8);
        serial->setParity(QSerialPort::NoParity);
        serial->setStopBits(QSerialPort::OneStop);
        serial->setFlowControl(QSerialPort::NoFlowControl);
        bool result = serial->open(QIODevice::ReadWrite);
        if (!result) {
            qDebug()<<"Failed to open port: "<< serial->portName()<<"error"<<serial->errorString();
        } else QMessageBox::information(this, "Info", "Вы успешно подключились");
    } else qDebug()<<"Вы не выбрали порт";
}

void MainWindow::handleError(QSerialPort::SerialPortError error)
{
    if (error == QSerialPort::ResourceError) QMessageBox::critical(this, tr("Critical Error"), serial->errorString());
}
void MainWindow::nextpageforresult() {
    Twindow = new testsresults(this);
    Twindow->show();
}

static const uint8_t CRC_TABLE[256] = {
    0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15,
    0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
    0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65,
    0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
    0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5,
    0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
    0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85,
    0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
    0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2,
    0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
    0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2,
    0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
    0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32,
    0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
    0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42,
    0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
    0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C,
    0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
    0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC,
    0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
    0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C,
    0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
    0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C,
    0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
    0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B,
    0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
    0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B,
    0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
    0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB,
    0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
    0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB,
    0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3
};

uint8_t crc8ccitt(uint8_t crc, const void * data, uint32_t size,MainWindow::queue_t*q) {
    uint8_t val = crc;
    
    uint8_t * pos = (uint8_t *) data;
    uint8_t * end = pos + size;
    bool checkcrc = false;
    
    while (pos < end) {
        if (pos-q->buffer>=q->buffer_size&&!checkcrc) {
            pos-=q->buffer_size;
            end-=q->buffer_size;
            checkcrc = true;
        }
        val = CRC_TABLE[val ^ *pos];
        pos++;
    }
    
    return val;
}
uint8_t crc8ccitt(uint8_t crc, const void * data, uint32_t size) {
    uint8_t val = crc;

    uint8_t * pos = (uint8_t *) data;
    uint8_t * end = pos + size;

    while (pos < end) {

        val = CRC_TABLE[val ^ *pos];
        pos++;
    }

    return val;
}

const unsigned int CRC32TAB[256] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D};
uint32_t crc32i(unsigned int crc, const void*data, uint32_t lbuf)
{
    uint8_t *pbuf = (uint8_t *) data;
    crc ^= 0xFFFFFFFF;

    while ( lbuf-- )
    {

        crc = CRC32TAB[ (crc & 0xFF) ^ *pbuf++ ] ^ (crc >> 8);

    }
    return crc ^ 0xFFFFFFFF;
}

uint32_t crc32i(unsigned int crc, unsigned char *pbuf, uint32_t lbuf,MainWindow::queue_t*q)
{
    crc ^= 0xFFFFFFFF;
    uint8_t counter = 0;
    bool checkcrc = false;
    while ( lbuf-- )
    {
        if (q->head+counter>=q->buffer_size&&!checkcrc) {
            pbuf-=q->buffer_size;
            checkcrc = true;
        }
        crc = CRC32TAB[ (crc & 0xFF) ^ *pbuf++ ] ^ (crc >> 8);
        counter++;
    }
    return crc ^ 0xFFFFFFFF;
}
uint32_t refactspisok(uint8_t * id_list,size_t size) {
    QList<qint32> copydigit;
    for (int i=0;i<size;i++,(id_list)++)
        copydigit.append(*id_list);
    if (size>2) {
        return (copydigit[0]<<24)+(copydigit[1]<<16)+(copydigit[2]<<8)+(copydigit[3]);
    }
    else return (copydigit[1]<<8)+(copydigit[0]);
}
static inline off_t min(off_t a,off_t b){
    return a<b?a:b;
}
QString put(MainWindow::queue_t *q,QByteArray ba,size_t size) {
    char*data = ba.data();
    if (q->buffer_size - q->bytes_avail<size) return nullptr;
    const size_t part1 = min(size,q->buffer_size-q->tail);
    const size_t part2 = size-part1;
    memcpy(q->buffer+q->tail,data,part1);
    memcpy(q->buffer,(uint8_t *)data+part1,part2);
    q->tail = (q->tail+size)%q->buffer_size;
    q->bytes_avail+=size;
    QString s = QString(ba.toHex());
    return s.remove(' ');
}


uint32_t get(MainWindow::queue_t*q,MainWindow::HEADing*headrecord) {
    uint32_t data = 0;
    for (int i=3;i>=0;i--) {
        data = data<<8;
        data&=0xffffff00;
        data += q->buffer[(q->head+headrecord->LengthMessage+i-4)%q->buffer_size];
    }
    return data;

}

bool get(MainWindow::queue_t *q,uint8_t*data,size_t size) {
    if (q->bytes_avail<size) size = q->bytes_avail;
    for (size_t i=0;i<size;i++) {
        data[i] = q->buffer[(q->head+i)%q->buffer_size];
    }
    q->head = (q->head+size) %q->buffer_size;
    q->bytes_avail-=size;
    return true;
}
uint32_t get(MainWindow::queue_t *q,size_t size) {
    if (q->bytes_avail<size) size = q->bytes_avail;
    uint8_t data1[4];
    for (size_t i=0;i<size;i++) {
        data1[i] = q->buffer[(q->head+i)%q->buffer_size];
    }
    q->head=(q->head+size) %q->buffer_size;
    q->bytes_avail-=size;
    if (size==1) return *data1; else return refactspisok(data1,size);
}

void writetoTS1(MainWindow::queue_t *q,MainWindow::BODYmsg*datarecord) {
    datarecord->TS1 = get(q,sizeof(datarecord->TS1));
}
void writetoTS2(MainWindow::queue_t *q,MainWindow::BODYmsg*datarecord,MainWindow::HEADing*headrecord) {
    for (int i=0;headrecord->LengthMessage-8>i;i++) {
        if (q->head==q->buffer_size) {
            q->head = q->head%q->buffer_size;
            datarecord->TS2.append(*(q->buffer+(q->head++)));
            q->bytes_avail--;
        }
        else {
            datarecord->TS2.append(*(q->buffer+(q->head++)));
            q->bytes_avail--;
        }
    }
    q->head%=q->buffer_size;
}

void writetoTS3(MainWindow::queue_t *q,MainWindow::BODYmsg*datarecord) {
    datarecord->TS3 = get(q,sizeof(datarecord->TS3));
}
QByteArray functionforwrite(uint32_t operationfalse,MainWindow::queue_t*q,MainWindow::BODYmsg*datarecord,int getsuzesoftypes,QByteArray data) {
    memcpy(data.data()+getsuzesoftypes,&(operationfalse),4);
    getsuzesoftypes+=sizeof(datarecord->TS1);
    uint32_t getnoewCSTS = crc32i(0, (data.data()), 4);
    memcpy(data.data()+getsuzesoftypes,&(getnoewCSTS),4);
    data.resize(16);
    return data;

}
void writetofiles(QByteArray ba) {
    QFile file(".//results.txt");
    if (!file.open(QFile::WriteOnly|QFile::Text)) {
        qDebug()<<"Файл не открылся";
        return;
    }
    QTextStream stream(&file);
    stream<<ba;
    file.close();


}
//Задачи
//учесть длину сообщения контрольную сумму для тс3 и првоерка на стриния и запись си + обработка кода ошибок
//=================================
QByteArray writerostruct(MainWindow::HEADing*headrecord,MainWindow::BODYmsg*datarecord,MainWindow::queue_t *q,uint8_t*shufflearr,uint8_t*GSCarray,int size,QByteArray*TOWRITE_FOR_SPO) {
    QString loopstr;
    uint8_t standartcontent[6] { 0x24,0x09,0x08,0x00 };
    QByteArray data(174,'\0');
    uint32_t operationfalse;
    int getsuzesoftypes = sizeof (headrecord->Separatorattribute)+sizeof (headrecord->Namecomand)+sizeof (headrecord->LengthMessage);
    memcpy(data.data(),standartcontent,sizeof (standartcontent));
    memcpy(data.data()+getsuzesoftypes,&headrecord->Indifier,1);
    getsuzesoftypes+=sizeof(headrecord->Indifier);
    uint8_t getnowCS = crc8ccitt(0,data.data(),5);
    memcpy(data.data()+getsuzesoftypes,&getnowCS,1);
    getsuzesoftypes+=sizeof (headrecord->ControSum);
    QList<qint32> getlistlength;
    QString checklength = (QString)headrecord->LengthMessage;
    uint8_t*headformember = q->buffer+q->head;
    headrecord->Separatorattribute = 0;
    switch (headrecord->Namecomand) {
    case 0x02:{
        if (crc32i(0,headformember,headrecord->LengthMessage-4,&(*q))==(get(&(*q),&(*headrecord)))) {
            writetoTS1(q,datarecord);
            uint32_t getreevrsedig=0;
            uint8_t massiveforTS1[4];
            for (int i=0;i<sizeof(massiveforTS1);i++) {
                massiveforTS1[i]=datarecord->TS1>>(8*(3-i));
                getreevrsedig += massiveforTS1[i]<<(8*i);
            }
            datarecord->TS1 = getreevrsedig;
            datarecord->TS2.clear();
            writetoTS2(q,datarecord,headrecord);
            writetoTS3(q,datarecord);
            for (int i=0;i<datarecord->TS2.size();i++) {
                TOWRITE_FOR_SPO->append(datarecord->TS2[i]);
            }
            if (TOWRITE_FOR_SPO->size()==datarecord->TS1) {
                return functionforwrite(UVK20_RES_OK_SPOLOAD,q,datarecord,getsuzesoftypes,data);
            }
            else if (TOWRITE_FOR_SPO->size()<datarecord->TS1){
                return functionforwrite(UVK20_RES_OK,&(*q),&(*datarecord),getsuzesoftypes,data);
            }
            else if (datarecord->TS2.size()>datarecord->TS1) {
                return functionforwrite(UVK20_RES_FAIL_SPOLOAD,q,datarecord,getsuzesoftypes,data);
            }

        } else {
            return functionforwrite(UVK20_RES_FAIL_CS,q,datarecord,getsuzesoftypes,data);
        }

    }
    case 0x10:{
        operationfalse = UVK20_RES_OK_SIERASE;
        for (int i=0;i<size;i++) {
            GSCarray[i] = rand();
        }
        memcpy(data.data()+getsuzesoftypes,&(operationfalse),4);
        getsuzesoftypes+=sizeof (datarecord->TS1);
        for (int i=0;i<size;getsuzesoftypes++,i++)
            memcpy(data.data()+getsuzesoftypes,&GSCarray[i],1);
        uint32_t getnoewCSTS = crc32i(0, (data.data()+8), size+4);
        memcpy(data.data()+getsuzesoftypes,&(getnoewCSTS),4);
        data.resize(size+14);
        return data;
        break;


    }
    case 0x08:{
        if (crc32i(0,headformember,headrecord->LengthMessage-4,&(*q))==*(uint32_t*)((q->buffer+(q->head+headrecord->LengthMessage-4)%q->buffer_size))) {
            writetoTS1(q,datarecord);
            writetoTS2(q,datarecord,headrecord);
            writetoTS3(q,datarecord);
            operationfalse = UVK20_RES_OK;
        }
        else {
            operationfalse = UVK20_RES_FAIL_CS;
        }
        //проверка на запись и стирание в зависимости от команды
        memcpy(data.data()+getsuzesoftypes,&(operationfalse),4);
        uint32_t getnoewCSTS = crc32i(0, (data.data()+getsuzesoftypes), 4);
        getsuzesoftypes+=sizeof (datarecord->TS1);
        memcpy(data.data()+getsuzesoftypes,&(getnoewCSTS),4);
        data.resize(16);
        return data;
        break;
    }
        // Запись серии
    case 0x04:{
        uint8_t keyarr[80] = {};
        if (crc32i(0,headformember,headrecord->LengthMessage-4,&(*q))==*(uint32_t*)((q->buffer+(q->head+headrecord->LengthMessage-4)%q->buffer_size))) {
            writetoTS1(q,datarecord);
            writetoTS2(q,datarecord,headrecord);
            writetoTS3(q,datarecord);
            operationfalse = UVK20_RES_OK;
            for (int i=0;i<size/2;i++) {
                datarecord->TS2[i]^=GSCarray[i];
                keyarr[shufflearr[i]] = datarecord->TS2[i];
            }
            if (keyarr[3]!=seria2[3+80*keyarr[3]]) {
                memcpy(&seria2[80*keyarr[3]],keyarr,sizeof (keyarr));
            } else {
                operationfalse = UVK20_RES_FAIL_CMND;
            }
        }
        else {
            operationfalse = UVK20_RES_FAIL_CS;
        }
        memcpy(data.data()+getsuzesoftypes,&(operationfalse),4);
        uint32_t getnoewCSTS = crc32i(0, (data.data()+getsuzesoftypes), 4);
        getsuzesoftypes+=sizeof (datarecord->TS1);
        memcpy(data.data()+getsuzesoftypes,&(getnoewCSTS),4);
        data.resize(16);
        return data;
        break;
    }
    case 0x05:{
        uint8_t keyarr[80] = {};
        for (int i=0;i<size/2;i++) {
            shufflearr[i]=i;
        }
        for (int i=0,indexforchange=0,bubble=0;i<size/2;i++) {
            indexforchange = GSCarray[i+80]%80;
            bubble = shufflearr[indexforchange];
            shufflearr[indexforchange] = shufflearr[i];
            shufflearr[i] = bubble;
        }
        if (crc32i(0,headformember,headrecord->LengthMessage-4,&(*q))==*(uint32_t*)((q->buffer+(q->head+headrecord->LengthMessage-4)%q->buffer_size))) {
            writetoTS1(q,datarecord);
            writetoTS2(q,datarecord,headrecord);
            writetoTS3(q,datarecord);
            operationfalse = UVK20_RES_OK;
            for (int i=0;i<size/2;i++) {
                datarecord->TS2[i]^=GSCarray[i];
                keyarr[shufflearr[i]] = datarecord->TS2[i];
            }
            if (keyarr[3]!=seria2[3+80*keyarr[3]]) {
                memcpy(&seria2[80*keyarr[3]],keyarr,sizeof (keyarr));
            } else {
                operationfalse = UVK20_RES_FAIL_CMND;
            }
        }
        else {
            operationfalse = UVK20_RES_FAIL_CS;
        }
        memcpy(data.data()+getsuzesoftypes,&(operationfalse),4);
        uint32_t getnoewCSTS = crc32i(0, (data.data()+getsuzesoftypes), 4);
        getsuzesoftypes+=sizeof (datarecord->TS1);
        memcpy(data.data()+getsuzesoftypes,&(getnoewCSTS),4);
        data.resize(16);
        return data;
        break;
    }
    case 0x07:{
        if (crc32i(0,headformember,headrecord->LengthMessage-4,&(*q))==*(uint32_t*)((q->buffer+(q->head+headrecord->LengthMessage-4)%q->buffer_size))) {
            operationfalse = UVK20_RES_OK_SIERASE;
            if (seria2[7]==datarecord->TS1) {
                memset(seria2,0,1280*sizeof (uint8_t));
            } else {
                if (seria2[1287]==datarecord->TS1) {
                    memset(seria2,1280,1280*sizeof (uint8_t));
                }
            }
        }
        else {
            operationfalse = UVK20_RES_FAIL_CS;
        }
        memcpy(data.data()+getsuzesoftypes,&(operationfalse),4);
        uint32_t getnoewCSTS = crc32i(0, (data.data()+getsuzesoftypes), 4);
        getsuzesoftypes+=sizeof (datarecord->TS1);
        memcpy(data.data()+getsuzesoftypes,&(getnoewCSTS),4);
        data.resize(16);
        return data;
        break;
    }
    case 0x01:
    case 0x03:
    case 0x06: {
        operationfalse = UVK20_RES_OK_SIERASE;
        if (headrecord->Namecomand==0x06) {
            if (seria2[0]==0xff&&seria2[1]==0x44) memset(seria2,0,1280*sizeof (uint8_t)); else operationfalse = UVK20_RES_FAIL_SIERASE;
        }
        if (headrecord->Namecomand==0x03) {
            if(SPOmassive[0]==0x33) memset(SPOmassive,0,1280*sizeof (unsigned char)); else operationfalse = UVK20_RES_OK;
        }
        memcpy(data.data()+getsuzesoftypes,&(operationfalse),4);
        uint32_t getnoewCSTS = crc32i(0, (data.data()+getsuzesoftypes), 4);
        getsuzesoftypes+=sizeof (datarecord->TS1);
        memcpy(data.data()+getsuzesoftypes,&(getnoewCSTS),4);
        data.resize(16);
        return data;
        break;
    }
    default:qDebug()<<"incorrect command"; break;
    }
}

void MainWindow::serialRecieve()
{
    QByteArray ba;
    QString fropdata;
    fropdata = put(&queue,serial->readAll(),serial->bytesAvailable());
    qint32 i = 0;
    int id=0;
    // uint32_t operationfalse = 0x80000000;
    while (i<fropdata.size()-id) {
        if (i%2==0&&i!=0)
        {
            fropdata.insert(i+id,'-');
            id++;
        }
        i++;
    }
    //Контрольная сумма TS1 И ДЛИНА СООБЩЕНИЯ ПЕРВЫЕ МЛАДШИЕ БАЙТЫ НА ПРИЕМ  И НА ОТПРАВКУ
    while (queue.bytes_avail) {
        if (datahead.Separatorattribute==0x24) {
            if ((queue.tail-queue.head>=datahead.LengthMessage&&queue.tail>queue.head)||(queue.head>queue.tail&&queue.buffer_size-queue.head+queue.tail>=datahead.LengthMessage)) {
                serial->write(writerostruct(&datahead,&databodymess,&queue,shufflearr,GSCarray,sizeof(GSCarray),&TOWRITE_FOR_SPO));
            }
            else return;
        }
        if (*(queue.buffer+queue.head)==0x24&&queue.bytes_avail>=6) {
            if(crc8ccitt(0,queue.buffer+queue.head,5,&queue)==*(queue.buffer+(queue.head+5)%queue.buffer_size)) {
                qDebug()<<"ok";
                datahead.Separatorattribute = get(&queue,sizeof(datahead.Separatorattribute));
                datahead.Namecomand=get(&queue,sizeof(datahead.Namecomand));
                datahead.LengthMessage=get(&queue,sizeof(datahead.LengthMessage));
                datahead.Indifier=get(&queue,sizeof(datahead.Indifier));
                datahead.ControSum = get(&queue,sizeof(datahead.ControSum));
                if ((queue.tail-queue.head>=datahead.LengthMessage&&queue.tail>=queue.head)||(queue.head>queue.tail&&queue.buffer_size-queue.head+queue.tail>=datahead.LengthMessage)) {
                    QByteArray getrequest = writerostruct(&datahead,&databodymess,&queue,shufflearr,GSCarray,sizeof(GSCarray),&TOWRITE_FOR_SPO);
                    serial->write(getrequest);
                    writetofiles(getrequest);
                }
                else {
                    ui->textEdit->append(fropdata);
                    return;
                }
            }
        } else {
            if(queue.bytes_avail){
                queue.head+=1%queue.buffer_size;
                queue.bytes_avail--;
            }
        }
    }
    ui->textEdit->append(fropdata);
    QMessageBox::critical(this, tr("Ok"), "Чтение завершено");
}
//24 01 26434333 65 2D 44235511 56764565345466457643321232 10813178
//
void MainWindow::on_pushButtonExit()
{
    msgBox->setText("Выход");
}
void MainWindow::on_pushButtonWritetootherCOMport()
{
    QString gettext = ui->textEdit->toPlainText().trimmed();
    QByteArray ba = gettext.toUtf8();
    serial->write(ba);
}
